## 导入黑马点评项目

`jdbc:mysql://localhost:3306/hmdp?characterEncoding=utf8&useUnicode=true&useSSL=false&autoReconnect=true`



![chrome_oLkEjWLq4c.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_oLkEjWLq4c.png)

![idea64_lbSqqdPOrB.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_lbSqqdPOrB.png)

地址👉`E:\Tools\nginx-1.18.0`

在该目录下所在窗口输入cmd,执行命令`start nginx.exe`，即可启动。

我们默认前端访问接口8080，后端8081.

### IDE点击service添加springboot启动模块

如果下方栏没有Services的同学点击IDEA左上角View->Tools Windows->Services添加。

在这一步中我遇到了一些问题，导入项目后IDE无法识别到springboot，查看后发现我根本没有用maven导入！于是我重新将项目导入并加载启动Maven后一切都好了。

## 基于传统Session实现登录

### 业务流程

![chrome_gQvt2fYV9H.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_gQvt2fYV9H.png)

提交验证码，校验，生成验证码并保存在本地(session)，为**用户输入验证码**做验证准备。不一致则拒绝，一致验证码则下一步**根据手机号查询用户信息**，查询数据库**用户是否存在**，不存在创建新用户写入到数据库中，若存在，将用户保存在session。

以后访问关键业务需要校验登录状态。如何进行session校验？

我们知道**session是基于cookie的**，**每一个session都会有一个sessionID保存在浏览器当中**，当用户请求访问时一定会携带他的cookie，ciookie里就有它的sessionID，进而帮助我们从session中获取用户是否存在（是否登录过）。

一般我们后续操作会用到用户信息，因此我们需要将其缓存到本地。一般我们将用户保存到**ThreadLocal**中。（线程域对象，每一个请求到达微服务，都将成为一个独立的线程）。

### 不用ThreadLocal将出现的问题

如果只是将信息保存在本地变量，可能会出现多线程并发修改的安全问题。而ThreadLocal将会把数据保存在**每一个线程的内部**，每个线程都有独立的存储空间，相互之间没有干扰。

### 功能一：发送短信验证码

#### 整体流程（大框架）

编写一个业务的接口，去处理前端提交的请求（传过来的手机号）

![chrome_Ab1Oj5juc5.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_Ab1Oj5juc5.png)

找到Controller层，创建service层服务（提供方法接口）（Alt+Enter快速创建）

![idea64_jNMnqZa51a.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_jNMnqZa51a.png)

通过创建接口方法，找到服务接口，进一步查找到它的**实现类**。继续alt+enter实现对应方法。

![ShareX_MXQgtAVCvn.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/ShareX_MXQgtAVCvn.png)

它是一个通用的结果对象👇（点开详情）

![idea64_4rDdotnq0L.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_4rDdotnq0L.png)

因此这里我们可以调用Result里的静态方法，ok~

![idea64_TohaFFAXzS.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_TohaFFAXzS.png)

#### 内部细节逐一实现

```java
@Override
    public Result sendCode(String phone, HttpSession session) {
        // 1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) {
            // 2.如果不符合，返回错误信息
            return Result.fail("手机号格式错误！");
        }
        // 3.符合，生成验证码
        String code = RandomUtil.randomNumbers(6);
        // 4.先保存到session
        session.setAttribute("code",code);
        // 5.（模拟）在发送验验证码
        log.debug("发送短信验证码成功，验证码:{}", code);
        // 6. 返回OK
        return Result.ok();
    }
```

一般校验手机号（是否符合位数）会采用正则表达式(Regex)，**utils包**下已经准备好了正则表达式的`RegexPatterns` 工具类，与`RegexUtils`工具类。

**随机生成器**生成六位验证码。这里用到我们引入依赖的**hutool工具类**（百宝箱，什么都有）中的**RandomUtil**

接下来就简单了，保存到session的api。

发送验证码需要去调用第三方平台（阿里云e.g），暂时略过，用`@Slf4j`写个假的。

![chrome_mAbKdChFmg.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_mAbKdChFmg.png)

重启后就OK噜。

此时点开后台可以发现写的日志log.debug会有反馈结果~

![idea64_ApFBaNbfp7.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_ApFBaNbfp7.png)

#### 功能二：登录跳转

![chrome_kmHqTCofgL.gif](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_kmHqTCofgL.gif)

我们在点击登录按钮后可以在F12控制台看发送的请求信息，以及对应参数（json格式)。

#### 复习一下注解与缩写知识

O一般代表Object（对象的意思）

- **POJO**：Plain Ordinary Java Object（简单Java对象、原生对象），**只包含简单的get/set方法**

- VO：View Objecet（视图对象），如html、jsp

- **DTO**：Data Transfer Object（数据传输对象），并**不在页面上做展示，只是传输用**

- ORM：Object Relationship Mapping（对象关系映射）

- DM：Domain Model（领域模型），比如银行、保险、电商、物流、医疗就是领

- DDD：Domain Driven Design（领域驱动设计）

- **DAO**：Data Access Object（**数据访问对象**）

- DO：Data Object（数据对象）

- BO：Business Object，业务对象。

- NPE：java.lang.NullPointerException的简称。

- OOM：Out Of Memory，内存溢出。

- ReDOS：Regular expression Denial of Service，正则表达式拒绝服务攻击。

这一步中属性传递用到了request注解。前端提交的是一个json风格，后台接收就必须要用到`@RequestBody`注解，并且有一个DTO实体类对象。

#### 为什么反向校验？而不用正向校验

![idea64_q6GNWHUZgm.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_q6GNWHUZgm.png)

不需要if嵌套，形成钻石型（菱形代码）

### 细节：query

![idea64_Ws9DWudi2b.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_Ws9DWudi2b.png)

要用到sql语句，这里我们采用了mybatis-plus的形式。而这个query方法实际上是接口impl实现类自带的，因为它继承自ServiceImpl，而后者是由mybatis-plus提供的。它能够帮助我们实现**单表的CRUD**。

![idea64_851A5hPmRC.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_851A5hPmRC.png)

```java
@Override
    public Result login(LoginFormDTO loginForm, HttpSession session) {
        // 每个请求都要做独立的校验
        // 1.校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)) {
            return Result.fail("手机号格式错误！");
        }
        // 2.校验验证码
        Object cacheCode = session.getAttribute("code");  //session里的code
        String code = loginForm.getCode();                  //前端的code
        if(cacheCode == null || !cacheCode.toString().equals(code)){
            // 3.不一致，报错
            return Result.fail("验证码错误");
        }
        // 4.一致，根据手机号查询用户(数据库查) select * from tb_user where phone = ?
        User user = query().eq("phone", phone).one();
        // 5.判断用户是否存在
        if (user == null) {
            // 6.不存在，创建新用户并保存
            user = createUserWithPhone(phone);
        }
        // 7.保存用户信息到session中
        session.setAttribute("user", user);
        return Result.ok();
    }

    private User createUserWithPhone(String phone) {
        // 1.创建用户
        User user = new User();
        user.setPhone(phone);
        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
        // 2.保存用户
        save(user);
        return  user;
    }
```

#### 前端启动不了问题

因为是第二天再继续做这个项目，检查后发现原来是忘了启动nginx。前后端分离模式。再重发一下这张总览图👇它是通过nginx服务器再统一到猫（服务端），以猫为契机连接后端数据库（开发阶段用IDEA打开）。

![chrome_mZHizI50Iq.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_mZHizI50Iq.png)

### 功能三：登录验证

查询当前用户信息，用户请求会带上Cookie（里面包含SessionID)

### 存在的潜在问题

随着后续业务开发都需要进行用户验证。每一个XXXController都写非常繁冗，因此我们可以使用SpringMVC提供的**拦截器**去简化步骤。但拦截器同时有问题，后续Controller需要用户信息，同时考虑线程问题。这时又双叒叕用到了我们的**ThreadLocal**!是不是非常熟悉呢，再瑞吉外卖中同样使用到了它来保存拦截器中的用户id信息。

ThreadLocal是一个线程对象，每一个进入到猫的请求都是**一个独立的线程**。将来ThreadLocal会在**线程内单独开辟一个内存空间，去保存对应用户**。每个线程相互不干扰。

![idea64_jUQ0OW0hJj.png](C:\Users\up\AppData\Roaming\marktext\images\39e5ce9aa5ad7327c13da91758abced7f257c6b1.png)

实现该接口，重写里面两个方法。

快捷键`Ctrl+i`快速**重写方法**。

第五步中的utils工具包下有一个UserHolder工具类，里面定义了一个ThreadLocal的常量，泛型为User。里面定义了三个方法，又因为是静态的，可以直接调用。

小细节👇对其进行强转：

![idea64_TaaLybMG60.gif](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_TaaLybMG60.gif)

#### 编写拦截器（未生效）

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.获取session
        HttpSession session = request.getSession();
        // 2.获取session中的用户
        Object user = session.getAttribute("user");
        // 3.判断用户是否存在
        if (user == null) {
            // 4.不存在，拦截;返回401状态码：未授权
            response.setStatus(401);
            return false;
        }
        // 5.存在，保存用户信息到ThreadLocal
        UserHolder.saveUser((UserDTO) user);
        // 6.放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //移除用户
        UserHolder.removeUser();
    }
}
```

#### 配置拦截器

在config（配置）包下编写MvcConfig类，首先让它去去实现WebMvcConfigurer。重写addInterceptors方法（添加拦截器）。

`InterceptorRegistry`是拦截器的注册器。

需要拦截哪写路径（exclude排除）（...代表可变参数，可以填写多个不同的值）

![idea64_6wXpEIL0rM.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_6wXpEIL0rM.png)

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/upload/**",
                        "voucher/**"
                );
    }
}
```

#### 返回（已登录状态下）用户详情信息

回到UserController中，

```java
@GetMapping("/me")
    public Result me(){
        // 获取当前登录的用户并返回
        UserDTO user = UserHolder.getUser();
        return Result.ok(user);
    }
```

#### 小问题：隐藏用户敏感信息

一般我们只需要返回用户id和手机号就可以了，并不需要连同更隐私信息一起返回。这是有泄露风险的。使用`UserHolder.getUser`过于直接粗暴简单。而它是由我们编写的拦截器中通过session获取的信息，session存的信息过多，因为**session是tomcat的内存空间**，对整个服务来讲**压力也越大**。而存入session信息的**源头**是最初做Login登录功能时暴露的问题👇

![idea64_93eqerXSEP.gif](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_93eqerXSEP.gif)

现在我们要做的是修改最初开始的**存储力度**。这里我们在dto（专门用来传输实体数据的包）包下仅录入基本信息。

```java
@Data
public class UserDTO {
    private Long id;
    private String nickName;
    private String icon;
}
```

笨蛋法是手动的将查询到的user信息一个一个添加到新new出来的userDto对象中。但这里我们用到一个工具类BeanUtil（它也是Hutool里包含的工具类）能够帮助我们拷贝属性。

**需要注意的是，我们先前在对login登录时做的拦截器时保存在utils包下的，而排除login等操作在外，配置拦截器（new一个拦截器对象的意思，同时开放或排除哪写路径）这家伙才是放在config包下的，不要搞混淆了。**

![idea64_gNS4BEj00k.gif](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/idea64_gNS4BEj00k.gif)

## 集群的session共享问题

指**多台Tomcat无法共享session存储空间**。

![chrome_ghXUzHDXhb.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_ghXUzHDXhb.png)

当请求切换到不同tomcat时，原先存储在一台tomcat中的session在其他猫里时看不到的。

虽然我们做到这个系统是一个单体式架构，但我们这一台猫将来为了应对并发，肯定需要做水平扩展——部署多个，**形成负载均衡的集群**。

此时当请求进入nginx，它会在多台猫之间做轮询（负载均衡），也就是说每一台猫都会由自己的负载空间。

#### 解决方案：让session可以共享

猫提供了session拷贝的功能，但数据拷贝也有几个问题：内存空间的浪费，拷贝数据有延迟。因此该方案被淘汰了。

替代方案必须满足：（redis）

- 数据共享

- 内存存储（session是基于内存的，读写效率高）

- key,value结构（因为session就是一种非常方便的存取方案）

redis首先是在猫以外的存储方案，**因此任何一台猫都能访问到redis**，因此任何一台猫都能访问到redis，由此实现了**数据共享**！

因此，**用redis替代session是势在必行的选择了。**

## 基于Redis实现共享session登录

业务上的变化：验证码保存到redis中，而redis中value有很多种类型的数据结构，因此我们需要考虑这个问题。（string就OK了）第二个问题，session的特点是**每一个不同的浏览器在发送请求时都有一个独立的session**！也就是说在tomcat内部维护了很多的session。

而redis是一个共享的内存空间，因此不能都用code为key。必须确保不同用户做手机号验证时key都得是不同的。于是我们转换了一个思路：既然拥有唯一性，那么直接使用手机号作为key不就好了吗？

这样做不仅能确保唯一性，还可以**有助于将来获取验证码去验证。**

之前基于session登录时我们不需要考虑取数据的问题，因为猫会自动帮我们维护session。实际上，**创建session时会自动形成sessionID，写到用户浏览器的Cookie里**，用户之后的每次请求都会带着cookie，也就是sessionID,这样就能很容易找到session。

但现在用的redis，可每日会去帮你维护id什么的。你得自己取。（这就是设计的技巧）

#### 保存对象应该用到哪种数据类型呢？

在redis种保存单个对象时，常见方式有两种：

1. string结构
   
   **将java对象，序列成json字符串**进行保存。
   
   字段与字段之间合成一个整体。

2. **Hash结构**
   
   哈希结构的value可以理解成map，拥有key，（field:name字段和value:jack）两块去保存，也就是说拆开了。字段之间独立分开，可以进行独立查询。内存占用更少，只需保存数据本身，没有:""等符号格式占用数据存储。

我们保存用户信息时不太推荐再使用手机号方式了，

而是**建议使用随机token为key存储用户数据**。（也就是**随机字符串**，可以用UUID来生成）。

以前登录校验通过sessionID方式，而现在的**登陆凭证就变成了token**。

有个问题，token猫是不会帮我们自己写到浏览器中的，所以我们只能自己手动的将生成的token返回给客户端（也就是浏览器）

![chrome_LnrlMe4sCV.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_LnrlMe4sCV.png)

#### 小问题：前端是如何每次访问请求都携带Token的

前端vue没看懂，暂时放一下[视频](https://www.bilibili.com/video/BV1cr4y1671t?p=32&spm_id_from=pageDriver&vd_source=baf5a4288b31a243832175ddb5cbd481)

直接用手机号会有信息泄露的风险。】

#### 新改动

在服务实现类中，通过`@Resource`注解，注入SpringRedisTemplate提供的api。
