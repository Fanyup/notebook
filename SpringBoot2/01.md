## 自动配置：

[这里面对于常用注解还挺详尽的](https://ithelp.ithome.com.tw/m/articles/10270418#:~:text=%40RestController%20%3A%20%E4%BD%9C%E7%94%A8%E7%9B%B8%E7%95%B6%E6%96%BC%40,%E5%85%AD%E5%80%8B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%83%E6%95%B8%E3%80%82)

## 自动配置-依赖管理

- 父项目parent是做依赖管理的，常用的依赖jar包。在springboot dependencies里面有很多。**几乎声明了所有开发中常用的依赖的版本号，所以我们无需写版本号！** 如果需要修改，
- 查看spring-boot-dependencies里规定当前版本的依赖，用的key名
- 可以`<property>`中间修改版本（就近依赖原则）
- 启动器：引用完整开发场景`sping-boot-starter-*`，*就是某种场景；第三方提供的 *-spring-boot-starter。所有场景启动器最底层的依赖就是spring-boot-starter

引入依赖默认都可以不写，但不是绝对的，引入的jar没在范围内还是要我们写版本号。

- 自动配好tomcat
  
  - 引入tomcat依赖(starter-tomcat)
  
  - 配置猫

- 自动配好springmvc（starter-springmvc)
  
  - 常用组件
  
  - 全套组件

主程序，**返回IOC容器，获得容器就能获得容器中的组件**（也就是以前说到配置容器，获取bean管理对象，意思时一样的，springboot底层还是沿用了spring的bean管理机制，也就是ioc控制反转，DI依赖注入和aop面向切面）。

有中央处理器dispatcherServlet，视图解析器viewResource，字符编码器。也就是说它帮我们配置好了所有web开发的场景。

还配置了默认的包结构，也就是默认的包扫描规则。所以说主程序得在外面，**它所在的包及其下面的所有子包里面的组件都会被扫描。** 若想改变包扫描可以用@SpringBootApplication(scanBasePackages="")(它是一个合成注解，复合的）修改指定路径。

- 各种配置都有默认值
  
  默认配置文件的值最终会绑定到某个类上，这个类在容器中创建对象。

- 按需加载所有自动配置项
  
  引入那些场景这个场景的配置才会生效。springboot中所有的自动配置功能都在spring-boo-autoconfigure包里，比方说引入

## 依赖管理-底层注解

### @Configuration和@Bean注解

以前我们想给容器中添加组件，以前在xml中写bean标签。现在我们给该**配置类**上面写上@Configuration就是告诉它这是一个配置类，等同于以前的配置文件，现在我们用Java Config，java对象属性添加，给方法添加@Bean 给容器中添加的组件（创建对象）以方法名作为组件的id（默认，也可以在注解里子定义），返回类型就是组件类型，返回的值就是在容器中返回的实例。（以前也是这样用@Bean注册主键的，默认是单实例的。）（也就是以前我们说的配置容器+获取对象）（现在**注册组件**）

**配置类也是容器中的一个组件**，run.getBean()可以查出来。

单实例也就是说外部无论对配置类中的这个组件注册方法调用多少起，它都是一个。配置类注解有属性默认`proxyBeanMethods =true`，获取到代理对象。springboot始终会检查这个组件在容器中是否有，如果有就会始终保持单实例。单实例解决的是**组件依赖**。这是springboot2的一个更新。若不依赖组件，也就是说其他组件不依赖它，可写false，这样启动会变快。

### @Component,@Controller,@Service,@Repository

### @ComponentScan,@Import

@Import给容器中添加（导入）组件，类上面，可以是配置类,Controller都行，里面是数组.class，默认组件的名字就是全类名。

### @Conditional条件装配

条件装配，满足该注解指定的条件，则进行组件注入，它下面有很多子（派生）注解。OnBean（有容器中存在bean组件时）OnClass(当容器中有某个类时)...

比方说用户组件依赖宠物组件的方法（创建宠物，用户拥有它），现在把宠物组件的@Bean注解去掉掉，它就不是IOC容器的组件了，它变成了一个普通方法！这时用@ConditionalOnBean在用户组件该类上标注，它是条件注解，如果在容器中有该组件时才注册该用户组件。**所以就算有@Bean注解它也不生效了！** **方法上和类上都可以标注。**

### @ImportResource导入配置文件

类上

导入资源，以前我们用xml配置文件配置了非常多的注解，xml方式配置的bean组件是没有的。如果我们不想切换成注解方式，只需在该类上用该注解："classpath:bean.xml"，导入Spring的配置文件

### 1、@ConfigurationProperties配置绑定

方式一：

以前我们读取properties配置文件，用原生代码输入流很麻烦。现在只需要一个注解就可以了。

prefix前缀。类中属性和配置文件哪个属性绑定（配置文件属性中的前缀），然后把它加到容器中 **@Compontent** ，只有在容器中的组件，才会拥有springboot提供的强大功能。

### 2、@EnabledConfigurationProperties（xxx.class)

方式二**一定要在配置类上**，因为它是容器中的组件,类上加它，**开启属性配置绑定功能**。把这个组件自动注册到容器中。又时第三方类时没有@Component注册组件，就没有把它加导容器中。更别提自动装配了，它都不在就没法调用啊。

### @Autowired属性自动注入

### @RequestMapping处理指定路径的请求

### 自动配置原理

复合（合承）注解@SpringBootApplication，它是核心注解。

- `@SpringBootConfiguration`
  
  代表当前是一个配置类，也就是说我们的主main程序也是一个核心配置类。

- `@ComponentScan`
  
  指定扫描哪些。组件扫描器

- ⭐:`EnableAutoConfiguation`
  
  它是两个注解的合成：
  
  - `@AutoConfiguationPackage`
    
    自动配置包；
    
    `@Import({Registrar.class})`给容器中导入一个组件，现在给容器中导的是一个Registrar(登记员)，成哥静态类中有两个方法，给容器批量注册一系列组件。
    
    将指定的一个包下的所有组件导入进来。这个包就是main程序所在的包及子包下。
  
  - `@Import({AutoConfigurationImportSelector.class})`
    
    给容器批量导入一些组件，获取所有需要导入到容器中的配置类。利用loadSpringFactories工厂加载，得到所有组件：从META-INF/spring.factories来加载一个文件。默认扫描我们在这个位置的文件。核心Jar包中的META-INF下有这个/
    
    文件里面写死了spring-boot一启动就要给容器中加载的所有配置类。但是！我们以前测试时发现在容器中实际上并没有那么多组件！也就是说有些生效，有些不生效。那么这里就有一个**按需开启配置项**，也就是说127个场景的自动配置启动时默认全部加载，但最终会按需配置。
    
    怎么个按需配置办法？ 用之前那个**条件注解**呀！@ConditionalOnxxx，有这个包才会有xx类，才会使其生效。按照条件装配注解，最终会按需配置。

具体条件装配注解是如何工作的呢？它的流程是什么，让我们走一遍试试吧！

springboot设计模式：默认会在底层配好所有的组件，但如果有，则**以用户配置的优先**。@ConditionalOnMissingBean

总结起来：

- springboot先来**加载**所有的自动配置类;xxxxautoConfiguration导入组件

- **每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值**,xxxxProperties里面拿值（它和配置文件进行了绑定）

- 生效的配置类会给容器中装配很多的组件。

- 只要容器中有这些组件，相当于这些功能就有了。

定制化配置：

- 用户直接自己@Bean替换底层的组件

- **用户去看这个组件时获取的配置文件什么值**，去修改（**覆盖**）就行了。

也就是说我们只要会改springboot的配置文件，我们就无敌了！这也是我们的目标！将来整合出任何场景我们都会配置了。

**哪些种改法？**

1. 官方文档查文档

2. 查底层（尚硅谷15）

## 最佳实践

- 引入场景依赖
  
  如何找场景依赖，除了第三方starter，官方文档也有说他自己的。

- 查看自动配置了哪些
  
  - 这些是底层的，我们一旦导入场景，就能找到对应的自动配置，一般都生效了，就是有点麻烦）就是去找哪些生效了哪些没生效
  
  - 最快的办法:application.properties配置文件中：
    
    `debug=true`开启debug模式，执行main程序就能看到**自动配置报告，知道哪些生效了，哪些没生效。** negative都是不生效的。positive生效。可以**分析源码**

- 是否需要修改配置项
  
  - 参照文档修改配置项（数据库账号密码之类）
  
  - 自己分析到xxxxProperties绑定了配置文件的哪些（哪些是一一对应的，覆盖它就好了）
    
    我们配一个好玩的~banner一启动的图
  
  - 自定义加入或替换组件
    
    改配置不满意？@Bena,@Component以前spring的东西用起来~
  
  - 自定义器XXXCustomizer"定制器"

### 简化开发

#### Lombok

1. pom.xml引入依赖

2. IDEA安装插件

注意它的有参构造器是全参构造器！我们只想要个别只能老方法创建了。

#### dev-tools

开发者工具[Developing with Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools)

```xml
<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
```

`Ctrl+Fn+F9`启动main程序，重新编译一遍

就是说以后静态文件修改等，类文件有变化——**自动重启**

**现在是重启**而不是重加载，把项目重新编译一些。Build Project。静态文件就不重启了，直接用就行了。

#### Spring Initalizr

初始化向导。之前用过的那种方式。帮我们创建好了项目结构，主程序类，加好架构，引入依赖。

以后咱都用这个方式了。

## 配置文件

### yaml

适合用来做以数据为中心的配置文件。

`key: value`（注意中间有空格！）

- 大小写敏感

- 缩进标识层级关系（一般不允许Tab；常使用空格）

- 井号标识注释#

- **写字符串无需加引号**，加引号会表示不同的意义。
  
  - 普通字符串加单双引号是没有关系的
  
  - 转义特殊字符(\n这些）就不同了：
    
    双引号会作为换行输出（不会转义，没改变它的行为）
    
    单引号会作为字符串输出（会转义，会改变它的行为，**不让你变！**）

数据类型：

- 字面量：单个的，不可分割的值：date,boolean,string,number,null...
  
  - `key: v`

- 对象，两种写法:
  
  - ```yaml
    k:[空格]
     k1:[空格]v1
     k2: v2
    #行内写法
    k: {k1:v1,k2:v2}
    ```

- 数组：array,list,queue
  
  - ```yaml
    k: [v1,v2,v3]
    #或者
    k:
     - v1
     - v2
     - v3
    ```

类上加@ConfigurationProperties可以帮我们省略前缀

创建属性配置文件后缀可以写`yml`可以写`yaml`

注意：**加层级换行前要写个空格！**

实现一下：

![chrome_tgpTSHUqcW.png](https://raw.githubusercontent.com/Fanyup/cloudimg/master/img/chrome_tgpTSHUqcW.png)

 @RequestMapping : 標示請求的位址，若用在類別上表示所有**回應請求的方法都是以該路徑作為父路徑**，而它還有六個重要的參數。

@ResopnseBody:**常用來處理application/json、application/xml 等Content-Type 類型的資料**，表示HTTP 訊息是JSON/XML 格式，需將其轉化為指定類型參數。

[这里面对于常用注解还挺详尽的](https://ithelp.ithome.com.tw/m/articles/10270418#:~:text=%40RestController%20%3A%20%E4%BD%9C%E7%94%A8%E7%9B%B8%E7%95%B6%E6%96%BC%40,%E5%85%AD%E5%80%8B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%83%E6%95%B8%E3%80%82)

### 配置文件注释提示

有一个**配置文件注释处理器**，它可以为我们的**yaml编写时有提示**。

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-configuration-processor</artifactId>
  <optional>true</optional>
</dependency>

```

**与业务无关，只是为了我们开发方便。** 这样我们需要在springboot打包的适合告诉它不要把这个注释处理器打包到Jar里面，类太多了，加载好多没用的东西。在打包插件(build-->plugin)

```xml
<configuration>
    <excludes>
        <exclude>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-configuration-processor</artifactId>
        </exclude>
     </excludes>
</configuration>
```

打包时没有这个配置处理器（**听说新版本不用排除了，默认exclude了~**）

## Web开发
